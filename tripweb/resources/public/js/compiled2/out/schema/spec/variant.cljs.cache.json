["^ ","~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$schema.spec.variant","~:imports",null,"~:requires",["^ ","~$utils","~$schema.utils","^8","^8","~$spec","~$schema.spec.core","^:","^:"],"~:uses",null,"~:defs",["^ ","~$option-step",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","e:\\DEV\\clojure\\trusty\\tripweb\\resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","~:line",12,"~:column",8,"~:end-line",12,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^G",[["~$o","~$params","~$else"]]]]]],"^E",true,"^3","~$schema.spec.variant/option-step","~:variadic",false,"^@","resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^D",19,"~:method-params",["^G",[["~$o","^I","^J"]]],"~:protocol-impl",null,"~:arglists-meta",["^G",[null,null]],"^B",1,"^A",12,"^C",12,"~:max-fixed-arity",3,"~:fn-var",true,"^F",["^G",["^H",["^G",[["~$o","^I","^J"]]]]]],"~$VariantSpec",["^ ","~:num-fields",3,"~:protocols",["^2",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$schema.spec.core/CoreSpec","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^3","~$schema.spec.variant/VariantSpec","^@","resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^D",23,"~:type",true,"^B",12,"~:internal-ctor",true,"^A",41,"~:record",true,"^C",41,"~:skip-protocol-flag",["^2",["^U","^V","^W","^X","^Y","^[","^10","^11","^12","^14","^15","^16","^17"]]],"~$->VariantSpec",["^ ","^>",null,"^?",["^ ","^@","e:\\DEV\\clojure\\trusty\\tripweb\\resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^A",41,"^B",12,"^C",41,"^D",23,"^1:",true,"~:factory","~:positional","^F",["^G",["^H",["^G",[["~$pre","~$options","~$err-f"]]]]]],"^3","~$schema.spec.variant/->VariantSpec","^L",false,"^@","resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^D",23,"^M",["^G",[["^1@","^1A","^1B"]]],"^N",null,"^O",["^G",[null,null]],"^B",1,"^1:",true,"^1>","^1?","^A",41,"^C",41,"^P",3,"^Q",true,"^F",["^G",["^H",["^G",[["^1@","^1A","^1B"]]]]]],"~$map->VariantSpec",["^ ","^>",null,"^?",["^ ","^@","e:\\DEV\\clojure\\trusty\\tripweb\\resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^A",41,"^B",12,"^C",41,"^D",23,"^1:",true,"^1>","~:map","^F",["^G",["^H",["^G",[["~$G__32597"]]]]]],"^3","~$schema.spec.variant/map->VariantSpec","^L",false,"^@","resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^D",23,"^M",["^G",[["^1F"]]],"^N",null,"^O",["^G",[null,null]],"^B",1,"^1:",true,"^1>","^1E","^A",41,"^C",41,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^1F"]]]]]],"~$variant-spec",["^ ","^>",null,"^?",["^ ","^@","e:\\DEV\\clojure\\trusty\\tripweb\\resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^A",54,"^B",7,"^C",54,"^D",19,"^F",["^G",["^H",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]]]],"~:doc","A variant spec represents a choice between a set of alternative\n   subschemas, e.g., a tagged union. It has an overall precondition,\n   set of options, and error function.\n\n   The semantics of `options` is that the options are processed in\n   order. During checking, the datum must match the schema for the\n   first option for which `guard` passes. During generation, any datum\n   generated from an option will pass the corresponding `guard`.\n\n   err-f is a function to produce an error message if none\n   of the guards match (and must be passed unless the last option has no\n   guard).","~:top-fn",["^ ","^L",false,"^P",3,"^M",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]],"^F",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]],"^O",["^G",[null,null]]]],"^3","~$schema.spec.variant/variant-spec","^L",false,"^@","resources\\public\\js\\compiled2\\out\\schema\\spec\\variant.cljs","^D",19,"^1J",["^ ","^L",false,"^P",3,"^M",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]],"^F",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]],"^O",["^G",[null,null]]],"^M",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]],"^N",null,"^O",["^G",[null,null]],"^B",1,"^A",54,"^C",54,"^P",3,"^Q",true,"^F",["^G",[["^1@","^1A"],["^1@","^1A","^1B"]]],"^1I","A variant spec represents a choice between a set of alternative\n   subschemas, e.g., a tagged union. It has an overall precondition,\n   set of options, and error function.\n\n   The semantics of `options` is that the options are processed in\n   order. During checking, the datum must match the schema for the\n   first option for which `guard` passes. During generation, any datum\n   generated from an option will pass the corresponding `guard`.\n\n   err-f is a function to produce an error message if none\n   of the guards match (and must be passed unless the last option has no\n   guard)."]],"~:require-macros",["^ ","~$macros","~$schema.macros","^1N","^1N","^7","^8","^8","^8"],"~:cljs.analyzer/constants",["^ ","~:seen",["^2",["^1A","~:schema","~$throws?","~:pre","~:else","~:wrap-error","^1@","~:err-f","^1B","~:schema.spec.variant/exception","~:options","~:guard"]],"~:order",["^1Y","^1W","^1T","^1Q","^1R","^1U","^1S","^1X","^1V","^1@","^1A","^1B"]],"^1I",null]